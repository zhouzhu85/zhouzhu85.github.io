---
layout: _post
title: Java基础整理
date: 2022-11-28 15:51:10
tags: 
  - 基础
category: 
  - Java
  - 基础
---
## 1.面向对象和面向过程的区别

### 面向过程
**优点**： 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗
资源;比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发，性能是
最重要的因素。

**缺点**： 没有面向对象易维护、易复用、易扩展

### 面向对象
**优点**： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特
性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护

**缺点**： 性能比面向过程低

### 构造器 Constructor 是否可被 override
构造器不能被重写（override）,但是可以被重载（overload）

### 重载和重写的区别
**重载**：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时，一般表现在继承中

**重写**：发生在父子类中，方法名、参数类型个数相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类，如果父类方法访问修饰符为private 则子类就不能重写该方法；一般表现在接口实现中

## Java 面向对象编程三大特性: 封装 继承 多态
### 封装
封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也就没有什么意义了。

### 继承
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类，通过使用继承我们能够非常方便地复用以前的代码

#### 关于继承，注意如下3点
1. 子类拥有父类非private得属性和方法
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法

### 多态
所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实现对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

在java中有两种形式可以实现多态：继承（多个子类对同一个方法的重写）和接口（实现接口并覆盖接口中同一个方法）。

## String StringBuffer 和 StringBuilder 的区别是什么 String 为什么是不可变的
### 可变性
简单的来说，String 类中使用final关键字字符数组保存字符串，private final char value[]，所以String对象是不可变的。而StringBuilder与StringBuffer 都继承了AbstractStringBuilder类，在AbstractStringBuilder 中也就是使用字符数组保存字符串char[]value但没有用final关键字修饰，所以这两种对象都是可变的。
StringBuilder 与StringBuffer 的构造方法都是调用父类构造方法也就是AbstractStringBuilder实现的

AbstractStringBuilder.java 源码如下：
```java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
 char[] value;
 int count;
 AbstractStringBuilder() {
 }
 AbstractStringBuilder(int capacity) {
 value = new char[capacity];
 }
```
### 线程安全性
String 中的对象是不可变的，也就可以理解为常量，线程安全。

AbstractStringBuilder 是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、inset、indexOf等公共方法，StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的，StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。

### 性能
每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象，StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用，相同情况下使用StringBuilder相比使用StringBuilder仅能获取10%~15%左右的性能提升，但却要冒多线程不安全的风险。

对于三者使用的总结：
1. 操作少量的数据 使用String
2. 单线程操作字符串缓冲区下操作大量数据 使用StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据 使用StringBuffer

## 在一个静态方法内调用一个非静态成员为什么是非法的
由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非 静态变量，也不可以访问非静态变量成员。

## 在 Java 中定义一个不做事且没有参数的构造方法的作用
Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。
## 接口和抽象类的区别是什么
1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法
2. 接口中的实例变量默认是 final 类型的，而抽象类中则不一定
3. 一个类可以实现多个接口，但最多只能实现一个抽象类
4. 一个类实现接口的话要实现接口的所有方法，而抽象类不一定
5. 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

## 成员变量与局部变量的区别有那些
1. 从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰；
2. 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存
3. 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值）；而局部变量则不会自动赋值。

## 一个类的构造方法的作用是什么 若一个类没有声明构造方法,该程序能正确执行吗 ?为什么?
主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。

## == 与 equals(重要)
### ==：
是判断两个对象的地址是不是相等，即，判断两个对象是不是同一个对象，（基本数据类型==比较的是值，引用数据类型==比较的是内存地址）
### equals()
是判断两个对象是否是相等，但他一般有两种使用情况：
* 情况1：类没有覆盖equals()方法，则通过equals()比较该类的两个对象时，等价通过“==”比较这两个对象
* 情况2：类覆盖了equals()方法，一般，我们都覆盖equals()方法来两个对象的内容相等，若他们的内容相等，则返回true（即认为这两个对象相等）

### 例子：
```java
public class test1 {
 public static void main(String[] args) {
 String a = new String("ab"); // a 为一个引用
 String b = new String("ab"); // b 为另一个引用,对象的内容一样
 String aa = "ab"; // 放在常量池中
 String bb = "ab"; // 从常量池中查找
 if (aa == bb) // true
 System.out.println("aa==bb");
 if (a == b) // false，非同一对象
 System.out.println("a==b");
 if (a.equals(b)) // true
 System.out.println("aEQb");
 if (42 == 42.0) { // true
 System.out.println("true");
 }
 }
}
```
### 说明：
* String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
* 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。

## hashCode 与 equals（重要）
面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？”
### hashCode（）介绍
hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函 数。 

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）
### 为什么要有 hashCode
**我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：**

当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如 果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Headfirst java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。
### hashCode（）与 equals（）的相关规定
1. 如果两个对象相等，则 hashcode 一定也是相同的
2. 两个对象相等,对两个对象分别调用 equals 方法都返回 true
3. 两个对象有相同的 hashcode 值，它们也不一定是相等的
4. **因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖**
5. hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

## java8 并行流怎么解决线程安全问题
在Java 8中，使用并行流进行并行操作时，存在线程安全的问题。当多个线程同时访问共享的可变状态时，可能会导致数据竞争和不确定的结果。为了解决这个问题，可以考虑以下几点：

1. **避免共享状态：** 最简单的方法是避免在并行流操作中使用共享的可变状态。尽量将操作设计为无状态的，即不依赖于共享状态的结果。这样可以避免多个线程之间的数据竞争。

2. **使用线程安全的数据结构和操作：** 如果无法完全避免共享状态，可以使用线程安全的数据结构，如`ConcurrentHashMap`、`ConcurrentLinkedQueue`等。这些数据结构提供了线程安全的操作方法，可以在并行流操作中安全地使用。此外，Java 8还提供了一些线程安全的操作，比如`Collections.synchronizedList()`方法可以将普通的List转换为线程安全的List。

3. **使用原子操作：** 原子操作是不可分割的操作，可以保证在多线程环境下的线程安全性。Java 8提供了`java.util.concurrent.atomic`包，其中包含了一些原子类，如`AtomicInteger`、`AtomicLong`等。这些原子类能够进行原子状态更新，可以在并行流操作中使用以确保线程安全。

4. **使用同步：** 在某些情况下，无法使用线程安全的数据结构或原子操作来处理共享状态。这时可以使用`synchronized`关键字或`ReentrantLock`等同步机制来保护共享状态的访问。通过加锁，可以确保同一时间只有一个线程可以访问共享状态，从而避免数据竞争。

需要注意的是，并行流虽然提供了方便的并行操作，但并不是所有的操作都适合并行化。在使用并行流进行操作前，需要评估是否真正需要并行化以及是否存在线程安全的问题。只有在合适的情况下，并结合适当的线程安全策略，才能安全地使用并行流解决线程

